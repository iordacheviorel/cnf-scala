\chapter{Related work}

The work closest to ours is by Barroso et
al.~\cite{DBLP:journals/corr/abs-2003-05081}, who verify a CNF
transformation for propositional logic in the Why3~\cite{why3}
verification platform. They use the textbook approach, but they rely
on a particular strategy (first, remove implication, then: compute the
negation normal form, etc.) This makes their proof much simpler,
especially w.r.t. termination. One theoretical difference is that they
model truth assignments as functions from variables to truth values
and therefore their specification is closer to the mathematical
treatment of logic (we instead model truth assignment as finite
sequences, but we ensure they are sufficiently large for the context
in which they are used). Barroso et al. emphasize the verification of
continuation-passing style of the CNF transformation, which is out of
the scope of our paper.

Michaelis and Nipkow~\cite{DBLP:conf/types/MichaelisN17} mechanize and
prove Tseitin's transformation in Isabelle/HOL as part of the
formalization~\cite{Propositional_Proof_Systems-AFP} of a series of
propositional proof systems. The implementation is functional, based
on first generating fresh names for all distinct subformulae and then
adding the corresponding clauses for each internal node of the input
formula. The fact that the fresh names are generated at the very
beginning seems to make the proof simpler. As the emphasis is placed
on metatheoretical considerations, efficiency is not the main
concern. In our Dafny approach, the implementation is more efficient
and is compositional: each subformula is recursively translated into a
set of clauses.

G\"{a}her and Kunze~\cite{gaher_et_al:LIPIcs.ITP.2021.20} implement
and verify Tsetin's transformation in the Coq proof assistant as part
of the proof of the Cook-Levin theorem. The algorithm is implemented
as a fixpoint (terminating, pure, recursive function) in the
functional language of the Coq proof assistant. The function is very
similar to our implementation: it takes a subformula and a natural
starting from which fresh identifiers can be chosen. It returns the
set of clauses for the subformula, the new variable associated to the
subformula and a new number to be used for freshness. The inductive
invariant \texttt{tseytin\textunderscore formula\textunderscore repr}
used for the proof is also very similar to what we have independently
found. Since the implementations are in very different proof
environments, isolating Tseitin's transformation in both developments
and performing a more detailed comparison could be used to understand
the pros and cons of the two proof assistants (Dafny and Coq).

Verified transformation into CNF should be a first step in verified
SAT solvers that take as input arbitrary formulae. The SAT solver {\tt
  versat}~\cite{DBLP:conf/vmcai/OeSOC12} was implemented and verified
in the Guru programming language using dependent types. The solver is
verified to be sound: if it produces an {\tt UNSAT} answer, then the
input formula truly is unsatisfiable. Blanchette and
others~\cite{DBLP:journals/jar/BlanchetteFLW18} present a certified
SAT solving framework verified in the Isabelle/HOL proof
assistant. The proof effort is part of the \emph{Isabelle
  Formalization of Logic} project. The framework is based on
refinement: at the highest level sit several calculi like CDCL and
DPLL, which are formally proved. Depending on the strategy, the
calculi are also shown to be terminating. Another SAT solver verified
in Isabelle/HOL is by Mari\'{c}~\cite{DBLP:journals/jar/Maric09}. In
contrast to previous formalization, the verification methodology is
not based on refinement. Instead, the Hoare triples associated to the
solver pseudo-code are verified in Isabelle/HOL. In subsequent
work~\cite{DBLP:journals/corr/abs-1108-4368}, Mari{\'c} and Janičić
prove in Isabelle the functional correctness of a SAT solver
represented as an abstract transition system. Andrici and
Ciobâcă~\cite{DBLP:journals/corr/abs-2007-10842,DBLP:journals/corr/abs-1909-01743}
verify an implementation of DPLL in Dafny. Another formalization of a
SAT solver (extended with linear arithmetic) is by
Lescuyer~\cite{lescuyer:tel-00713668}, who verifies a DPLL-based
decision procedure for propositional logic in Coq and exposes it as a
reflexive tactic. Finally, a decision procedure based on DPLL is also
verified by Shankar and Vaucher~\cite{DBLP:journals/entcs/ShankarV11}
in the PVS system. For the proof, they rely on subtyping and dependent
types. Berger et al. have used the Minlog proof assistant to extract a
certified SAT solver~\cite{DBLP:journals/corr/BergerLFS15}.  {\bf None
  of the verified SAT solvers described above perform a CNF
  conversion}, with the exception of the reflexive procedure by
Lescuyer~\cite{lescuyer:tel-00713668}. Lescuyer notes that
implementing Tseitin's procedure in Coq proved to be \emph{much more
  challenging} and therefore implements a lazy CNF transformation.
