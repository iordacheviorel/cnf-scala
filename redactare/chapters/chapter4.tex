\chapter{The Tseitin Conversion}

In this section, we discuss our formalization of the Tseitin
conversion into CNF~\cite{Tseitin}, also called definitional
CNF~\cite{harrison}. We first briefly recall the Tseitin
transformation via a short example.



  Consider the formula \( \varphi = \lnot x_1 \lor x_2 \). Choose
  fresh variables \( y_1, y_2 \) for the two subformulae
  \( \lnot x_1 \) and \( \lnot x_1 \lor x_2 \), respectively. Add to
  the resulting CNF clauses that encode that each of the two variables
  is equivalent to the corresponding subformula:

  \begin{enumerate}
  \item for \( y_1 \equiv \lnot x_1 \), add the clauses
    $ y_1 \lor x_1, \lnot y_1 \lor \lnot x_1 ;$
  \item for \( y_2 \equiv y_1 \lor x_2 \), add the clauses:
    $ \lnot y_1 \lor y_2, \lnot x_2 \lor y_2, \lnot y_2
      \lor y_1 \lor x_2 .$
  \end{enumerate}

  Finally, add a clause consisting of a single literal: the variable
  corresponding to the initial
  formula~\footnote{Tseitin~\cite{Tseitin} proposes to add the
    negation of this literal, the initial formula being valid iff the
    resulting formula is unsatisfiable; modern treatments
    diverge~\cite{harrison}.}. The final result is:
  \((y_1 \lor x_1) \land (\lnot y_1 \lor \lnot x_1) \land (\lnot y_1
  \lor y_2) \land (\lnot x_2 \lor y_2) \land (\lnot y_2 \lor y_1 \lor
  x_2) \land y_2.\)
  The result of applying our implementation of Tseitin's algorithm 
  on the above formula is:
  [[3, 1], [-3, -1], [-3, 4], [-2, 4], [-4, 3, 2], [4]], 
  where: \( 1 \Rightarrow x_1 \), \( 2 \Rightarrow x_2 \), 
  \( 3 \Rightarrow y_1 \), \( 4 \Rightarrow y_2 \).



The guarantee offered by this transformation is that the resulting
formula is equisatisfiable to the initial formula, as opposed to
equivalent for the textbook transformation discussed in
Section~\ref{sec:textbook}. The advantage is that the size is at most
O(1) times bigger than the initial formula.

\section{Data Structures}

In verifying the definitional CNF transformation, we use the same data
type \texttt{FormulaT} for the input formula as in the previous
formalization. However, for the output formula, we choose to represent
literals as integers, clauses as sequences of integers and CNF
formulae as sequences of clauses, similar to the well-known DIMACS
format:

\begin{dafny}
predicate method validLiteral(lit : int) { lit <= -1 || lit >= 1 }
predicate validClause(clause : seq<int>) {
  forall lit :: lit in clause ==> validLiteral(lit) }
predicate validCnfFormula(f : seq<seq<int> >) {
  forall clause : seq<int> :: clause in f ==> validClause(clause) }
\end{dafny}

Note that \texttt{valid} in the predicates above reflects standard
Dafny use rather than semantical validity in the logical sense. As
variables are represented by non-negative integers, we consistently
use the following function (methods) to convert between variables and
literals:

\begin{dafny}
predicate validVariable(v : int) { v >= 0 }
function method posVarToLit(v : int) : int
  requires validVariable(v);
  ensures posVarToLit(v) >= 1 && validLiteral(posVarToLit(v)); 
{ v + 1 }
function method negVarToLit(v : int) : int
  requires validVariable(v);
  ensures negVarToLit(v) <= -1 && validLiteral(negVarToLit(v)); 
{ (-v) - 1 }
function method litToVar(l : int) : int
  requires validLiteral(l);
{ if (l <= -1) then (-l) - 1 else l - 1 }
\end{dafny}

We represent assignments as sequences of booleans, just like in the
textbook transformation. To compute truth values, we use the following
predicates:

\begin{dafny}
predicate truthValueLiteral(lit : int, tau : seq<bool>)
    requires validLiteral(lit) && variablesUpToLiteral(lit, |tau|);
{ if lit < 0 then !tau[litToVar(lit)] else tau[litToVar(lit)] }
predicate truthValueClause(clause : seq<int>, tau : seq<bool>)
  requires validClause(clause) && variablesUpToClause(clause, |tau|);
{ exists lit :: lit in clause && truthValueLiteral(lit, tau) }
predicate truthValueCnfFormula(rf : seq<seq<int>>, tau : seq<bool>)
  requires validCnfFormula(rf) && variablesUpToCnfFormula(rf, |tau|);
{ forall clause | clause in rf :: truthValueClause(clause, tau) }
\end{dafny}

The predicates \texttt{variablesUpTo*} (with
\(\texttt{*} \in \{ \texttt{CnfFormula}, \allowbreak \texttt{Clause},
\texttt{Literal} \} \)), check that the assignment is sufficiently
large to account for all variables occurring in the formulae. We
consistently use the following convention: program variables such as
\texttt{f}, \texttt{f1}, \texttt{f2} stand for formulae of type
\texttt{FormulaT} and program variables such \texttt{rf}, \texttt{rf1}
stand for \emph{resulting formulae} of type \texttt{seq<seq<int> >}.

As the guarantee of the Tseitin transformation is equisatisfiability
between the initial formula and the resulting formula, we model this
by using the following predicates:

\begin{dafny}
predicate satisfiable(f : FormulaT) requires validFormulaT(f);
{ exists tau | |tau| == maxVar(f) :: truthValue(f, tau) }
predicate satisfiableCnfFormula(rf:seq<seq<int> >) requires validCnf[...](rf);
{ exists tau | |tau| == maxVarCnfFormula(rf) :: truthValueCnfFormula(rf, tau) }
predicate equiSatisfiable(f : FormulaT, rf : seq<seq<int> >)
    requires validFormulaT(f); requires validCnfFormula(rf);
{ satisfiable(f) <==> satisfiableCnfFormula(rf) }
\end{dafny}

The function methods \texttt{maxVar*} compute the maximum natural
number that represents a variable inside the formulae, plus
one. Therefore an assignment of size \texttt{maxVar*} is sufficiently
large to compute the truth value.% :
% \begin{Verbatim}
% function method maxVarCnfFormula(rf : seq<seq<int> >) : int
%   requires validCnfFormula(rf);
%   ensures maxVarCnfFormula(rf) >= 0;
%   ensures forall clause | clause in rf ::
%     variablesUpToClause(clause, maxVarCnfFormula(rf));
%   ensures variablesUpToCnfFormula(rf, maxVarCnfFormula(rf));
% {
%   if |rf| == 0 then
%     [...];
%     0
%   else
%     var result := Utils.max(maxVarClause(rf[0]),
%       maxVarCnfFormula(rf[1..]));
%     [...];
%     result
% }

% function method maxVar(f : FormulaT) : int
%   requires validFormulaT(f);
%   ensures variablesUpTo(f, maxVar(f)) && maxVar(f) >= 0;
% {
%     [...]
% }
% \end{Verbatim}

\section{The Algorithm}

The entry point to the algorithm is the method \texttt{tseitin}.

\begin{figure}[H]
\begin{Verbatim}[fontsize=\small, baselinestretch=0.1]
method tseitin(f : FormulaT) returns (result : seq<seq<int> >)
  requires validFormulaT(f);
  ensures validCnfFormula(result) && equiSatisfiable(f, result);
{ var n := maxVar(f); var v : int; 
  var end : int;      var rf : seq<seq<int>>;
  rf, v, end := tseitinCnf(f, n, n);
  result := rf + [[posVarToLit(v)]]; [...] }
\end{Verbatim}
\end{figure}

The guarantee is that the resulting CNF formula is equisatisfiable to the
initial one. The main work is performed by the method
\texttt{tseitinCnf}, which traverses the input formula recursively and
adds the right clauses to the result:

\begin{figure}[H]
\begin{Verbatim}[fontsize=\small, baselinestretch=0.1]
method tseitinCnf(f : FormulaT, n : int, start : int)
  returns (rf : seq<seq<int> >, v : int, end : int)
  requires variablesUpTo(f, n) && start >= n >= 0;
  ensures valid(f, rf, v, n, start, end);
  ensures tseitinSameValue(f, rf, v, n, start, end);
  ensures tseitinCanExtend(f, rf, v, n, start, end);
{ match f {
    case Or(f1, f2)        => {
      var rf1 : seq<seq<int> >; var rf2 : seq<seq<int> >;
      var v1 : int; var v2 : int;
      var mid : int;
      rf1, v1, mid := tseitinCnf(f1, n, start);
      rf2, v2, v := tseitinCnf(f2, n, mid);
      end := v + 1;
      rf := rf1 + rf2 + orClauses(v1, v2, v);
      proveCanExtendOr(f1,rf1,v1, f2, rf2, v2, n, start, mid, v, end, rf);
      proveSameValueOr(f1,rf1,v1, f2, rf2, v2, n, start, mid, v, end, rf);
    }
    case And(f1, f2)      => [...]  case Implies(f1, f2)  => [...]
    case DImplies(f1, f2) => [...]  case Not(f1) => [...]
    case Var(val) => [...]
} }
\end{Verbatim}
\end{figure}

The method \texttt{tseitinCnf} takes as input:
%
\begin{itemize}
%
\item a formula \texttt{f} to transform into CNF, which might be a
  subformula of the initial formula given to \texttt{tseitin};
%
\item a natural number \texttt{n} with the meaning that all variables
  in the initial formula are between \( 0 \) and \( n - 1 \);
%
\item a natural number \texttt{start}, with the meaning that the
  variables \texttt{start}, \texttt{start + 1}, \texttt{start + 2},
  \ldots are not used and can be safely used as fresh variables by the
  method.
%
\end{itemize}
%
Variables between \texttt{n} (inclusively) and \texttt{start}
(exclusively) might have been used for some other subformulae.

The method \texttt{tseitinCnf} returns as output:
%
\begin{itemize}
%
\item A set of clauses \texttt{rf} encoding that the freshly chosen
  variables are equivalent to the corresponding subformulae;
%
\item A variable \texttt{v} that corresponds to the input formula
  \texttt{f};
%
\item A number \texttt{end} with the meaning that the recursive call
  used fresh variables between \texttt{start} (inclusively) and
  \texttt{end} (exclusively) and therefore the variables \texttt{end},
  \texttt{end + 1}, \texttt{end + 2}, \ldots can be used safely as
  fresh after the call is finished.
%
\end{itemize}
%
The predicate \texttt{valid} is used to account for the validity of
the entire state of the algorithm:

\begin{dafny}
predicate valid(f : FormulaT, rf : seq<seq<int> >, v : int,
  n : int, start : int, end : int)
{ 0 <= n <= start <= end && variablesUpTo(f, n) && validCnfFormula(rf) &&
  validVariable(v) && variableInInterval(v, n, start, end) &&
  variablesInInterval(rf, n, start, end) }
\end{dafny}

The predicate \texttt{variablesInInterval(rf, n, start, end)} checks
that \texttt{rf} uses only the initial variables (between \( 0 \) and
\( n - 1 \) ) and fresh variables between \texttt{start} (inclusively)
and \texttt{end} (exclusively).

We discuss in more detail the implementation of the \texttt{Or} case
in \texttt{tseitinCnf} presented above. Note how the recursive call on
\texttt{f1} uses fresh variables between \texttt{start} (inclusively)
and \texttt{mid} (exclusively), while the recursive call on
\texttt{f2} uses fresh variables between \texttt{mid} (inclusively)
and \texttt{v} (exclusively). The variable \texttt{v} is therefore
used as the fresh variable corresponding to the entire formula
\texttt{f} = \texttt{Or(f1, f2)}. The final set of clauses is then the
union of \texttt{rf1} (set of clauses corresponding to \texttt{f1}),
\texttt{rf2} (set of clauses corresponding to \texttt{f2}) and
\texttt{orClauses(v1, v2, v)}, which encodes that \texttt{v} should be
equivalent to \texttt{Or(v1, v2)}:

\begin{dafny}
function method orClauses(v1 : int, v2 : int, v : int) : seq<seq<int> >
  requires validVariable(v1) && validVariable(v2) && validVariable(v);
{ [[negVarToLit(v), posVarToLit(v1), posVarToLit(v2)],
    [negVarToLit(v1), posVarToLit(v)], [negVarToLit(v2), posVarToLit(v)]] }
\end{dafny}
  
\section{The Proof}

The main difficulty in verifying the algorithm is coming up with the
right invariants. Assuming that \texttt{tseitinCnf(f, n, start)}
returns \texttt{rf, v, end}, we find that the following two invariants
explain the functional correctness of the algorithm:

\begin{enumerate}

\item any truth assignment \texttt{tau} to the initial \texttt{n}
  variables can be extended (uniquely) to a truth assignment
  \texttt{tau'} that makes \texttt{rf} true and such that the value of
  \texttt{f} in \texttt{tau} is the same as the value of \texttt{v} in
  \texttt{tau'};

\item vice-versa, any truth assignment to all \texttt{end} variables
  that makes \texttt{rf} true also makes \texttt{v} and \texttt{f}
  have the same truth value.

\end{enumerate}

We formalize the two invariants above in the predicates
\texttt{tseitinCanExtend} and \texttt{tseitinSameValue}:
\begin{figure}[H]
\begin{dafny}
predicate tseitinCanExtend(f : FormulaT, rf : seq<seq<int> >,
    v : int, n : int, start : int, end : int)
  requires valid(f, rf, v, n, start, end);
{ forall tau : seq<bool> | |tau| == n :: canExtend(tau,f,rf,v,n,start,end) }

predicate canExtend(tau : seq<bool>, f : FormulaT, rf : seq<seq<int> >, 
    v : int, n : int, start : int, end : int)
  requires |tau| == n && valid(f, rf, v, n, start, end);
{ exists tau' : seq<bool> | tau <= tau' && |tau'| == end ::
    truthValueCnfFormula(rf, tau') && truthValue(f, tau) == 
    truthValueLiteral(posVarToLit(v), tau') }

predicate tseitinSameValue(f : FormulaT, rf : seq<seq<int> >,
    v : int, n : int, start : int, end : int)
  requires valid(f, rf, v, n, start, end);
{ forall tau : seq<bool> | |tau| >= end && truthValueCnfFormula(rf, tau) ::
    [...] truthValueLiteral(posVarToLit(v), tau) == truthValue(f, tau) }
\end{dafny}
\end{figure}

We find that because \texttt{tseitinCanExtend} is of the form
\( \forall \_ . \exists \_ . \_ \) (nested quantifiers), it is useful
for verification performance to give a name to the
\( \exists \_ . \_ \) part, hence the predicate \texttt{canExtend}.
Dafny cannot prove the two predicates automatically, and therefore we
design helper lemma for each of the two invariants and for each of the
cases (\texttt{Or}, \texttt{And}, \texttt{Not}, \ldots).%  We present
% the proofs for the \texttt{Or} case, and the others are similar.
%
% The first of the two invariants is the most difficult to prove:
%
% \begin{Verbatim}
% lemma proveCanExtendOr( f1 : FormulaT, rf1 : seq<seq<int> >, v1 : int,
%     f2 : FormulaT, rf2 : seq<seq<int> >, v2 : int, n : int, start : int,
%     mid : int, v : int, end : int, rf : seq<seq<int> >)
%   requires 0 <= n <= start <= mid <= v;
%   requires valid(f1, rf1, v1, n, start, mid);
%   requires tseitinCanExtend(f1, rf1, v1, n, start, mid);
%   requires valid(f2, rf2, v2, n, mid, v);
%   requires tseitinCanExtend(f2, rf2, v2, n, mid, v);
%   requires rf == rf1 + rf2 + orClauses(v1, v2, v) && end == v + 1;
%   ensures valid(Or(f1, f2), rf, v, n, start, end);
%   ensures tseitinCanExtend(Or(f1, f2), rf, v, n, start, end);
% {
%   assert valid(Or(f1, f2), rf, v, n, start, end);
%   forall tau : seq<bool> | |tau| == n ensures canExtend(tau, Or(f1, f2),
%     rf, v, n, start, end);
%   {
%     ghost var tau1 :| tau <= tau1 && |tau1| == mid &&
%       truthValueCnfFormula(rf1, tau1) && 
%       truthValue(f1, tau) == truthValueLiteral(posVarToLit(v1), tau1);
%     ghost var tau2 :| tau <= tau2 && |tau2| == v &&
%       truthValueCnfFormula(rf2, tau2) &&
%       truthValue(f2, tau) == truthValueLiteral(posVarToLit(v2), tau2);
%     ghost var tau' := combine(tau, tau1, tau2, n, start, mid, v,
%         truthValue(Or(f1, f2), tau));
%
%     assert agree(tau', tau, 0, n);
%     assert agree(tau', tau1, start, mid);
%     assert agree(tau', tau2, mid, v);
%     [...]
%
%     lemmaOrClauses(v1, v2, v, tau');
%     assert canExtend(tau, Or(f1, f2), rf, v, n, start, end);
%   }
% }
% \end{Verbatim}
%
The main idea behind these proof is to combine two assignments
\texttt{tau1} and \texttt{tau2}, which necessarily agree on the first
\( n \) variables (the variables in the initial formula), into a
single assignment \texttt{tau'}. This is possible since the
\emph{interesting} assignments in \texttt{tau1} range from
\texttt{start} to \texttt{mid} and the \emph{interesting} assignments
in \texttt{tau2} range from \texttt{mid} to \texttt{v}; that is they
are disjoint. We ellide the computer-checked proof for space reasons.
% We elide 25
% lines of proof (replaced by \texttt{[...]})  that is used to properly
% prove that truth values of appropriate items transfer between
% \texttt{tau1} (resp. \texttt{tau2}) and \texttt{tau'}.

% An interesting proof technique that we use here is to reflect the
% meaning of the clauses returned by \texttt{orClauses} into the Dafny
% meta-language by using the following lemma:

% \begin{Verbatim}
% lemma lemmaOrClauses(v1 : int, v2 : int, v : int, tau : seq<bool>)
%     requires validVariable(v1) && validVariable(v2) && validVariable(v);
%     requires |tau| > v && |tau| > v1 && |tau| > v2;
%     ensures truthValueCnfFormula( orClauses(v1, v2, v), tau) <==>
%         ((truthValueLiteral(posVarToLit(v1), tau) ||
%         truthValueLiteral(posVarToLit(v2), tau)) <==>
%         truthValueLiteral(posVarToLit(v), tau));
% {
%     [...]
% }
% \end{Verbatim}

% The second invariant has a smaller proof for the \texttt{Or} case:

% \begin{Verbatim}
% lemma proveSameValueOr( f1 : FormulaT, rf1 : seq<seq<int> >, v1 : int,
%   f2 : FormulaT, rf2 : seq<seq<int> >, v2 : int, n : int, start : int, 
%   mid : int, v : int, end : int, rf : seq<seq<int> >)
%   requires 0 <= n <= start <= mid <= v;
%   requires valid(f1, rf1, v1, n, start, mid);
%   requires tseitinSameValue(f1, rf1, v1,
%       n, start, mid);
%   requires valid(f2, rf2, v2, n, mid, v);
%   requires tseitinSameValue(f2, rf2, v2,
%       n, mid, v);
%   requires rf == rf1 + rf2 + orClauses(v1, v2, v);
%   requires end == v + 1;
%   ensures valid(Or(f1, f2), rf, v, n, start, end);
%   ensures tseitinSameValue(Or(f1, f2), rf, v,
%       n, start, end);
% {
%   assert valid(Or(f1, f2), rf, v, n, start, end);
%   forall tau : seq<bool> | |tau| >= end && truthValueCnfFormula(rf, tau)
%     ensures truthValueLiteral(posVarToLit(v), tau) ==
%       truthValue(Or(f1, f2), tau)
%   {
%     [...]
%     lemmaOrClauses(v1, v2, v, tau);
      
%     assert truthValueLiteral(posVarToLit(v), tau) ==
%       truthValue(Or(f1, f2), tau);
%   }
% }
% \end{Verbatim}

% We elide 6 lines of proof. Note that we use the same proof technique
% of reflecting the meaning of \texttt{orClauses} into the Dafny
% meta-language.
  
